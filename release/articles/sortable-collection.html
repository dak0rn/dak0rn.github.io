<p>In a <a href="#post/parseQuery">recent post</a> I described how complex search queries can be parsed
to create the base for a cascading search function. The idea was that a search string like
this</p>
<pre><code>genre:jazz artist:&quot;Horace Silver&quot; the &quot;jazz messengers&quot;
</code></pre><p>is converted into an array of strings an objects like this one:</p>
<pre><code class="lang-javascript">[ {genre: &#39;jazz&#39;}, {artist: &#39;Horace Silver&#39;}, &#39;the&#39;, &#39;jazz messengers&#39; ]
</code></pre>
<p>Given such an array with criteria, it is quite easy to write a search algorithm that filters
a collection of models using two rules:</p>
<ul>
<li>If you have a criteria that is an object filter for the given model attributes only</li>
<li>If you have a string criteria filter all model attributes for it</li>
</ul>
<h2 id="what-s-bad-about-backbone-s-collection">What&#39;s bad about Backbone&#39;s Collection</h2>
<p>One might think <em>Hey, that looks like we can use <code>_.where</code> in Backbone.Collection</em>.
While <code>Backbone.Collect.where()</code>, the built-in filter function from underscore (or $alternative),
allows you to filter the stored models it has a major downside when it comes to views: the filter
functions return an array.</p>
<p>Thus, you often find code like this:</p>
<pre><code class="lang-javascript">var models = collection.find( generateFilterFunction(criteria) );

// Updates the view
viewCollection.reset();
viewCollection.set(models);
</code></pre>
<p>What happens here is that two collections are used; one stores all models
while the other stores only models filtered from the original collection.</p>
<p>But that is not what I want. I don&#39;t want to have two collections that have to be synced
manually all the time.</p>
<p>Thus, I have written this handy Backbone.Collection that keeps a copy of itself internally.
Even though it does not overwrite any built-in filter method it is not meant to be used with them.</p>
<h2 id="what-you-need">What you need</h2>
<p>As with the linked example above you have to include/export/... Backbone and underscore or lodash.
If you use userscore keep in mind that the query parsing function needs <code>_.trim()</code>. Thus, you have to
implement that manually.</p>
<pre><code class="lang-javascript">Backbone.Collection.extend({

    // Internal collection
    _raw: new (Backbone.Collection.extend({model:Model}))(),
    // Search term
    _term: null,


    initialize: function() {
        // Listen to events that change the collection
        this.listenTo(this, &#39;sync&#39;, this._synced, this );
        this.listenTo(this, &#39;add&#39;, this._added, this );
        this.listenTo(this, &#39;remove&#39;, this._removed, this );
    },


    _synced: function(stuff, data) {
        if( data ) {
            this._raw.reset();
            this._raw.add(data);

            if( this._term )
                this.filterCollection( this._term );
        }        
    },


    _added: function(model) {
        if( model ) {
            this._raw.add(model);

            if( this._term )
                this.filterCollection( this._term );
        }
    },


    _removed: function(model) {
        if( model ) {
            this._raw.remove(model);

            if( this._term )
                this.filterCollection( this._term );
        }
    },


    _filterArray: function(models, crit) {
        if( 0 === models.length )
            return models;

        var t = [];

        // Loop variables
        var i;
        var len;
        var prop;
        var val;
        var mval;
        var attrs = {};            // Object with criterias
        var keys = [];            // Keys to compare. Stored for performance.

        // If we got an object we compare all the keys
        // contained in the object with the models
        if( _.isObject(crit) ) {
            attrs = crit;
            keys = _.keys(attrs);
        }
        // If we get something else we compare all attributes
        // with whatever we got
        else {
            keys = _.keys( models[0].attributes );
            _.each(keys, function(k) { attrs[k] = crit; }); 
        }

        // all models ...
        _.each(models, function(target) {

            // and all attributes
            for( i = 0, len = keys.length; i &lt; len; i++ ) {
                prop = keys[i];
                val  = attrs[prop];
                mval = target.get(prop);

                if( _.isUndefined(mval) || _.isNull(val)  )
                    continue;

                // We only compare strings!
                val  = (&quot;&quot;+val ).toLocaleLowerCase();
                mval = (&quot;&quot;+mval).toLocaleLowerCase();

                // Contained or equal?
                if( val === mval || -1 &lt; mval.indexOf(val) ) {
                    t.push(target);
                    break;
                }
            }
        }, this);
        return t;
    },

    resetFilter: function() {
        this._term = null;
        this.filterCollection();
    },

    _parseQuery = function(what){
        var terms = [];

        // Split at spaces but keep quoted words together 
        var parts = what.match(/(?:[^\s&#39;&quot;]+|[&#39;&quot;][^&#39;&quot;]*[&#39;&quot;])+/g);

        // Process each part
        _.each(parts, function(e){

            // Remove leading and trailing quotes 
            e = _.trim(e,&#39;&quot;\&#39;&#39;);

            // Skip if invalid
            if( _.isEmpty(e) )
                return;

            // Find the position of the first colon
            var colon = e.indexOf(&#39;:&#39;);

            // If there is no colon just add the single string
            if( -1 === colon ) {
                terms.push(e);
                return;
            }

            // Get the part before the colon
            var key = e.substr(0, colon);

            // Criteria object
            var obj = {};

                       // Remove quotes from the part after
                       // the colon
            obj[key] = _.trim(e.substr(colon+1), &#39;\&#39;&quot;&#39;);

              // Add the criteria
            terms.push(obj);

        });

        return terms;
    },

    filterCollection: function(what) {

        var filtered = this._raw.slice();

        if( arguments.length ) {

            // Parse search term if it&#39;s a string
            if( _.isString(what) )
                what = this._parseQuery(what);
            // Not pretty but faster
            else if( ! _.isArray(what) )
                return;

            // Cache
            this._term = what;

            _.each( what, function(criteria){
                filtered = this._filterArray(filtered, criteria);
            }, this );

        }

        /*
         * The collection changes only if
         * - there is a different number of models now or
         * - if there are new models that matched the criteria
         */
        if( filtered.length !== this.models.length ||
             _.some(this.models, function(e) { return ! _.contains(filtered,e); } ) ) {

            this.reset(undefined,{silent:true});
            this.add(filtered, {silent:true});
            this.trigger(&#39;change&#39;);                    // Render again
        }

    }

});
</code></pre>
<p>The two important functions here are <code>filterCollection()</code> and <code>resetFilter()</code>. The latter resets
the collection by adding all originally contained models again.</p>
<p>The former function is responsible of filtering the collection. It stores all models in a Backbone.Collection
internally. <code>filterCollection()</code> accepts both strings and array. Strings are converted to an array of search
criteria automatically using the <code>_parseQuery()</code> function described in the referenced article.</p>
<p>The collection filters its models if you add or remove on. Thus, an added model may disappear automatically.
This is very useful if the user searches for something while the collection is being modified.</p>
<p>The collection updates itself only if the result set changes. If filter a filtered collection again (e.g. because
the user changed the search term) and the models stay the same you will not receive any change event.</p>
<h2 id="natives">Natives</h2>
<p>As written <a href="http://backbonejs.org/#Collection-Underscore-Methods">in the documentation</a> Backbone.Collection
supports underscore/lodash functions to retrieve a (sub-) set of models. If you do not overwrite them these
functions will only operate on the filtered collection.</p>
<h2 id="require-js">require.js</h2>
<p>Since I use require.js for a lot of my front-end applications this code is taken right out of one.
So, you can paste it into a require.js block to use it. Keep in mind to include the model.</p>
<pre><code class="lang-javascript">define([
     &#39;backbone&#39;,
     &#39;lodash&#39;,
     &#39;../model/Album&#39;,
 ], function(Backbone, _, Model) {

     return Backbone.Collection.extend({ ... });
 });
</code></pre>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">HTTP Access Control</a>
is an important feature of the security model for modern web applications. One part
of it is the <em>Access-Control-Allow-Headers</em> HTTP header that contains a list of
allowed HTTP headers.</p>
<p>For example, if you try to save a Backbone model in a JavaScript application
to the API running on another port Chrome will send an <code>OPTIONS</code> request
first determining if the access is allowed. Both <em>Access-Control-Allow-Origin</em>
and <em>Access-Control-Allow-Headers</em> have to contain values indicating allowed
headers and request origins.</p>
<p><em>Access-Control-Allow-Origin</em> is often a static property set per API so that
the global API option <code>headers</code> can be used to add a header field for that:</p>
<pre><code class="lang-javascript">new Espresso({
    headers: {
        &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;
    }
});
</code></pre>
<p>In general, <code>Access-Control-Allow-Headers</code> could be configured this way, too.
However, or testing purposes or during development it is often quite useful
to allow all headers. Since this property does not allow wildcards this can
be achieved by sending requested methods back.</p>
<p>This can be done in the root handler. If cascading is used all other handlers
will have this header field for their responses, too.</p>
<pre><code class="lang-javascript">api.resource(&#39;/&#39;, {
    get: function(request, response) {

        if( request.headers[&#39;access-control-request-headers&#39;] )
            response.headers[&#39;Access-Control-Allow-Headers&#39;] = request.headers[&#39;access-control-request-headers&#39;];
    }
});
</code></pre>
